<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Safety Plan Peace 2024" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Safety Plan Peace 2024">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gitbook_on":true,"repo_url":"<a href=\"https://github.com/NewGraphEnvironment/mybookdown-template/\" class=\"uri\">https://github.com/NewGraphEnvironment/mybookdown-template/</a>","report_url":"<a href=\"https://newgraphenvironment.github.io/mybookdown-template\" class=\"uri\">https://newgraphenvironment.github.io/mybookdown-template</a>","update_bib":true,"update_packages":false},"title":"Safety Plan Peace 2024"}
</script>

<title>Safety Plan Peace 2024</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
.title {
font-size: 18px;
color: Black;
text-align: center;
}
.author { 
font-size: 13px;
color: Black;
text-align: center;
}
.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Safety Plan Peace 2024</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2024-08-09<br />
Date Revised: 2024-09-08</p>
</div>
<p><br></p>
<p><br></p>
<div id="safety-plan---2024-073-sern-peace-fish-passage" class="section level1 unnumbered break-after-me">
<h1>Safety Plan - 2024-073-sern-peace-fish-passage</h1>
<p>The latest version of this pdf can be downloaded <a href="https://github.com/NewGraphEnvironment/safety_plan_peace_2024/raw/main/docs/safety_plan_sern-peace-fish-passage.pdf">here</a>.</p>
<p><br></p>
<p>The main goal of the fieldwork is baseline monitoring using electrofishing with crews from McLeod Lake. We will be at the six permitted electrofishing sites most of the time. Additionally, we may conduct fish passage (Phase 1) and habitat confirmation (Phase 2) assessments in the Carp and Crooked watershed groups as well. A summary of the potential sites for fish passage assessments, habitat confirmation assessments, and electrofishing is provided in Table <a href="#tab:tab-electrofishing-sites">5</a>, with kml (google earth) and gpx (garmin) files downloadable <a href="https://github.com/NewGraphEnvironment/safety_plan_peace_2024/raw/main/docs/sites_sern-peace-fish-passage_20240908_kml_gpx.zip">here</a>.</p>
<p><br></p>
<p>Georeferenced pdf maps can be accessed and downloaded <a href="https://hillcrestgeo.ca/outgoing/fishpassage/projects/parsnip/">here</a>.</p>
<p><br></p>
<div id="new-graph-employee-information" class="section level2 unnumbered">
<h2>New Graph Employee Information</h2>
<p>Al Irvine<br />
Vehicle: 2013 Toyota Tundra black w/flatdeck and yellow can-am quad<br />
Accommodation: 3396 Rosia Road, Prince George, BC V2K 4Y5</p>
<p><br></p>
<p>Lucy Schick<br />
Vehicle: 2006 Pontiac Vibe red<br />
Accommodation: 6596 Dawson Road, Prince George, BC V2K 5Y4</p>
<p><br></p>
</div>
<div id="crew-members" class="section level2 unnumbered">
<h2>Crew Members</h2>
<p>New Graph Employees Al Irvine and Lucy Schick will be joined by crews from McLoed Lake. All crew member information and emergency contacts can be found below.</p>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-crew">Table 1: </span>Crew members details and emergency contacts
</caption>
<thead>
<tr>
<th style="text-align:left;">
name
</th>
<th style="text-align:left;">
email
</th>
<th style="text-align:left;">
phone
</th>
<th style="text-align:left;">
satellite
</th>
<th style="text-align:left;">
emerg_name
</th>
<th style="text-align:left;">
emerg_email
</th>
<th style="text-align:left;">
emerg_phone
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Allan Irvine
</td>
<td style="text-align:left;">
<a href="mailto:al@newgraphenvironment.com" class="email">al@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
250-777-1518
</td>
<td style="text-align:left;">
must be contacted by inreach first. Cannot cold call
</td>
<td style="text-align:left;">
Tara Stark
</td>
<td style="text-align:left;">
<a href="mailto:tara@newgraphenvironment.com" class="email">tara@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
250-505-9854
</td>
</tr>
<tr>
<td style="text-align:left;">
Jillian Isadore
</td>
<td style="text-align:left;">
<a href="mailto:jillianmarie457@icloud.com" class="email">jillianmarie457@icloud.com</a>
</td>
<td style="text-align:left;">
778-349-8471
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Eugenia Isadore
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
 250-644-0418 
</td>
</tr>
<tr>
<td style="text-align:left;">
Tristan Salonas
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Bianca Prince
</td>
<td style="text-align:left;">
<a href="mailto:biancaprince@hotmail.com" class="email">biancaprince@hotmail.com</a>
</td>
<td style="text-align:left;">
250-730-1480
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Nathan Prince
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
250-617-5930
</td>
</tr>
<tr>
<td style="text-align:left;">
John Demont
</td>
<td style="text-align:left;">
<a href="mailto:justjohndumont@icloud.com" class="email">justjohndumont@icloud.com</a>
</td>
<td style="text-align:left;">
250-720-9700
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Nathan Prince
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
250-617-5930
</td>
</tr>
<tr>
<td style="text-align:left;">
Lucy Schick
</td>
<td style="text-align:left;">
<a href="mailto:lucy@newgraphenvironment.com" class="email">lucy@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
604-741-2032
</td>
<td style="text-align:left;">
807-790-9843
</td>
<td style="text-align:left;">
Sa Boothroyd
</td>
<td style="text-align:left;">
<a href="mailto:saboothroyd@gmail.com" class="email">saboothroyd@gmail.com</a>
</td>
<td style="text-align:left;">
604-740-7199
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="equipment-checklists" class="section level2 unnumbered">
<h2>Equipment Checklists</h2>
<p>PLEASE NOTE THAT EQUIPMENT CHECKLISTS ARE PROVIDED FOR THE OVERALL TEAM AND NOT ALL CREWS ARE REQUIRED TO HAVE ALL EQUIPMENT. ALTHOUGH ENCOURAGED FOR ALL ENVIRONMENTAL SCIENCE TECHNICIANS AND MONITORS TO HAVE THE PERSONAL EQUIPMENT NEW GRAPH ENVIRONMENT WILL HAVE ALL EQUIPMENT NECESSARY TO COMPLETE THE WORK.</p>
<p><br></p>
<p>MINIMUM REQUIREMENTS FOR EACH CREW MEMBER INCLUDES GOOD QUALITY AND APPROPRIATELY FITTING LIGHT WEIGHT WADERS AND SEPERATE WADING BOOTS (RUBBER SOLED), HAT, WATER AND A FOOD.</p>
<p><br></p>
<p>MINIMUM REQUIREMENTS FOR FIELD TRUCKS INCLUDE A QUALITY RADIO APPROPRIATE FOR FOREST SERVICE ROADS, OFF-ROAD CAPABLE TIRES IN GOOD CONDITION, SPARE TIRE, JACK, AND TOOLS.</p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:table-equipment">Table 2: </span>Personal Equipment Checklist - SEE NOTE ABOVE FOR MINIMUM REQUIREMENTS
</caption>
<thead>
<tr>
<th style="text-align:left;">
Equipment
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
GPS
</td>
<td style="text-align:left;">
water
</td>
</tr>
<tr>
<td style="text-align:left;">
Suncreen
</td>
<td style="text-align:left;">
food
</td>
</tr>
<tr>
<td style="text-align:left;">
Bugspray
</td>
<td style="text-align:left;">
gloves work
</td>
</tr>
<tr>
<td style="text-align:left;">
Polarized glasses
</td>
<td style="text-align:left;">
headlamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Bear Spray
</td>
<td style="text-align:left;">
clinometer
</td>
</tr>
<tr>
<td style="text-align:left;">
phone/camera
</td>
<td style="text-align:left;">
field vest (surveyors)
</td>
</tr>
<tr>
<td style="text-align:left;">
battery pack booster for phone
</td>
<td style="text-align:left;">
note book
</td>
</tr>
<tr>
<td style="text-align:left;">
Hat
</td>
<td style="text-align:left;">
Extra clothes
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit personal
</td>
<td style="text-align:left;">
rain gear
</td>
</tr>
<tr>
<td style="text-align:left;">
Waders
</td>
<td style="text-align:left;">
hand lens
</td>
</tr>
<tr>
<td style="text-align:left;">
Wading Boots (Rubber-soled only)
</td>
<td style="text-align:left;">
range finder
</td>
</tr>
<tr>
<td style="text-align:left;">
Ski poles
</td>
<td style="text-align:left;">
–
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:equip-crew">Table 3: </span>Crew Equipment Checklist - SEE NOTE ABOVE FOR MINIMUM REQUIREMENTS
</caption>
<thead>
<tr>
<th style="text-align:left;">
Crew Equipment Checklist
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
glasses safety
</td>
<td style="text-align:left;">
tape measure eslon
</td>
</tr>
<tr>
<td style="text-align:left;">
Hand saw
</td>
<td style="text-align:left;">
pilon x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Linesman Gloves x 3
</td>
<td style="text-align:left;">
Measuring board
</td>
</tr>
<tr>
<td style="text-align:left;">
Backroads Mapbook
</td>
<td style="text-align:left;">
Scale
</td>
</tr>
<tr>
<td style="text-align:left;">
Locational maps
</td>
<td style="text-align:left;">
Permits
</td>
</tr>
<tr>
<td style="text-align:left;">
Background Documents
</td>
<td style="text-align:left;">
Fish ID book
</td>
</tr>
<tr>
<td style="text-align:left;">
radio handheld
</td>
<td style="text-align:left;">
Site Cards / Field Guide
</td>
</tr>
<tr>
<td style="text-align:left;">
Satelite communicator
</td>
<td style="text-align:left;">
Minnow Traps
</td>
</tr>
<tr>
<td style="text-align:left;">
Field Safety Plan
</td>
<td style="text-align:left;">
Catfood
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit level 1
</td>
<td style="text-align:left;">
Flagging
</td>
</tr>
<tr>
<td style="text-align:left;">
First Aid binder stocked
</td>
<td style="text-align:left;">
Laptop w/basecamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Throw bags
</td>
<td style="text-align:left;">
GPS cable
</td>
</tr>
<tr>
<td style="text-align:left;">
polaski
</td>
<td style="text-align:left;">
Lazer level
</td>
</tr>
<tr>
<td style="text-align:left;">
shovel
</td>
<td style="text-align:left;">
Assessment cards fish passage
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher backpack
</td>
<td style="text-align:left;">
UAV
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher pressurized
</td>
<td style="text-align:left;">
Flow meter
</td>
</tr>
<tr>
<td style="text-align:left;">
hard hat
</td>
<td style="text-align:left;">
ATV
</td>
</tr>
<tr>
<td style="text-align:left;">
steel toed boots
</td>
<td style="text-align:left;">
bucket rigid x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Battery booster
</td>
<td style="text-align:left;">
bucket foldable
</td>
</tr>
<tr>
<td style="text-align:left;">
Compressor 12V
</td>
<td style="text-align:left;">
clove oil kit w/ instructions
</td>
</tr>
<tr>
<td style="text-align:left;">
Rubber boots (no-slip soles)
</td>
<td style="text-align:left;">
gloves leather
</td>
</tr>
<tr>
<td style="text-align:left;">
Small BT Speaker (for bears)
</td>
<td style="text-align:left;">
sharpies
</td>
</tr>
<tr>
<td style="text-align:left;">
Oakton Multimeter
</td>
<td style="text-align:left;">
ATV gas
</td>
</tr>
<tr>
<td style="text-align:left;">
Backpack Electrofisher
</td>
<td style="text-align:left;">
ATV lock
</td>
</tr>
<tr>
<td style="text-align:left;">
stop nets x 4
</td>
<td style="text-align:left;">
UAV battery charger
</td>
</tr>
<tr>
<td style="text-align:left;">
salt blocks
</td>
<td style="text-align:left;">
wader disinfectant kit
</td>
</tr>
<tr>
<td style="text-align:left;">
loose salt
</td>
<td style="text-align:left;">
GPS batteries
</td>
</tr>
<tr>
<td style="text-align:left;">
dip nets x 2
</td>
<td style="text-align:left;">
ATV helmets
</td>
</tr>
<tr>
<td style="text-align:left;">
tape measure hand
</td>
<td style="text-align:left;">
–
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:equip-truck">Table 4: </span>Truck Equipment Checklist - SEE NOTE ABOVE FOR MINIMUM REQUIREMENTS
</caption>
<thead>
<tr>
<th style="text-align:left;">
Equipment
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Hand saw
</td>
<td style="text-align:left;">
truck/car jack
</td>
</tr>
<tr>
<td style="text-align:left;">
radio truck
</td>
<td style="text-align:left;">
Battery booster
</td>
</tr>
<tr>
<td style="text-align:left;">
polaski
</td>
<td style="text-align:left;">
Compressor 12V
</td>
</tr>
<tr>
<td style="text-align:left;">
shovel
</td>
<td style="text-align:left;">
pilon x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher backpack
</td>
<td style="text-align:left;">
Tow strap
</td>
</tr>
<tr>
<td style="text-align:left;">
truck tow rope
</td>
<td style="text-align:left;">
–
</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
<div id="nearest-hospitals" class="section level2 unnumbered">
<h2>Nearest Hospitals</h2>
<div class="figure"><span style="display:block;" id="fig:hospital-1"></span>
<img src="data:image/png;base64,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" alt="University Hospital of Northern British Columbia - 1475 Edmonton St., Prince George, BC V2M 1S2 - 250-565-2000" width="100%" />
<p class="caption">
Figure 1: University Hospital of Northern British Columbia - 1475 Edmonton St., Prince George, BC V2M 1S2 - 250-565-2000
</p>
</div>
<p><br></p>
</div>
<div id="emergency-response-plan" class="section level2 unnumbered">
<h2>Emergency Response Plan</h2>
<p>New Graph’s detailed emergency response procedures can be found <a href="https://www.newgraphenvironment.com/hsp/plans-and-assessments.html#emergency-response-plan-erp-and-procedures">here</a>. These procedures should be reviewed and an emergency response plan should be completed for each job site. Our Emergency Responce Plan template can be downloaded <a href="https://github.com/NewGraphEnvironment/hsp/blob/master/data/form_templates/ERP_template.pdf">here</a>.</p>
<p><br></p>
</div>
<div id="driving" class="section level2 unnumbered">
<h2>Driving</h2>
<p>We will be driving on forest service roads where it is essential to exercise caution and adhere strictly to all radio use protocols to ensure our safety. Proper communication on these roads helps prevent accidents by keeping everyone informed about vehicle movements and road conditions. Please review the <a href="https://www.newgraphenvironment.com/hsp/safe-work-procedures-and-practices.html#resource-road-safety">resource road safety</a> and <a href="https://www.newgraphenvironment.com/hsp/safe-work-procedures-and-practices.html#radio-use">radio use</a> sections of our Health and Safety plan so that everyone stays safe.</p>
<p><br></p>
</div>
<div id="field-plan" class="section level2 unnumbered">
<h2>Field Plan</h2>
<p>The main goal of the fieldwork is baseline monitoring using electrofishing with crews from McLeod Lake. We will be at the 5 or 6 permitted electrofishing sites most of the time. In addition we may spend some time with fish passage assessments in areas of not only the Parsnip watershed group but also the Carp and Crooked watershed groups.</p>
<p>Field work methods will result in products feeding reporting formats such as <a href="https://www.newgraphenvironment.com/fish_passage_peace_2022_reporting/">here</a> for 2022 and <a href="https://www.newgraphenvironment.com/fish_passage_peace_2023_reporting/">here</a> for 2023. We generally follow procedures in:</p>
<ul>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">fish passage assessments</a> <span class="citation">(BC Ministry of Environment 2011)</span></p></li>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">habitat confirmations</a> <span class="citation">(Fish Passage Technical Working Group 2011)</span>.</p></li>
</ul>
<p><br></p>
<p>Presence/absence of fish, species composition/density and distribution limits can be useful for prioritizing which crossings are a best fit for fish passage restoration and help inform follow up monitoring so electrofishing and minnowtrapping may be conducted. Standard Fish and Fish Habitat Inventory Standard Field Form <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/laws-policies-standards-guidance/inventory-standards/aquatic-ecosystems">site cards</a> are used to gather habitat data, and the Field Guide to these site cards can be found <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/sitecard20.pdf">here</a>.</p>
<p><br></p>
<p>We have PIT tagging equipment so we could consider <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">tagging</a> fish captured at electrofishing sites to help us better understand population sizes and fish movement upstream and downstream of sites over the years.</p>
<p><br></p>
<p>We use digital field form using a product called <a href="https://merginmaps.com/?gclid=Cj0KCQjwxb2XBhDBARIsAOjDZ34oq-iMid3vRrgK1ZAkJ_yiz4aWY-LLF90PHiXzELbZIrxooV9vWKYaAgl2EALw_wcB">Mergin Maps</a> which syncs with QGIS. Please see our <a href="https://www.newgraphenvironment.com/fish_passage_guidebook/">Fish Passage Guidebook</a> for instructions on how to set up Mergin Maps and use our digital field forms. Please send me your usernames and we can begin to share projects/forms.</p>
<p><br></p>
<p>A guide to freshwater fish id such as <span class="citation">McPhail and Carveth (1993)</span> can be useful and can be downloaded <a href="https://a100.gov.bc.ca/pub/acat/documents/r13659/486FieldKeytoFreshwaterFishes1993Part1of2_1210014849226_8e248a8d30d97e6c45ef54a340babd2ffb57b14a3b16.pdf">here</a>.</p>
<!-- and an overview map of displaying potential sample locations is included as Figure 1. -->
<p><br></p>
<div id="check-in-procedures" class="section level3 unnumbered">
<h3>Check In Procedures</h3>
<p>Call, text or inreach Tara Stark (2505059854) each morning to share the plan for the day (i.e. name of roads and sites). Check in time is before 7 pm each evening although we regularly check in throughout the day (ex. at arrival to site, 1pm and 4pm) on the inreach or by text and report position/provide updates.</p>
<p><br></p>
<div id="procedures-for-failed-check-in---for-check-in-person" class="section level4 unnumbered">
<h4>Procedures for Failed Check-In - for Check in person</h4>
<p>Procedures are summarized in the following Figure. If phone call or inReach check-in is not received by 7pm send text to inreach units, call or text cell phones of field crew members. If no response please call accommodations then personal emergency contacts to see if they have heard anything. Wait 1 hour and text inreach, text or call cell phones and personal emergency contacts and accomodations again. Repeat after 2 hours (9 pm) - if no response then notify the RCMP of a missing persons in field.</p>
<p><br></p>
<div class="figure"><span style="display:block;" id="fig:flow-check-in-fail"></span>
<img src="data:image/png;base64,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" alt="Procedures for failed check-in" width="100%" />
<p class="caption">
Figure 2: Procedures for failed check-in
</p>
</div>
<p><br><br><br></p>
<!-- <br><br><br><br><br><br><br> -->
<div class="figure"><span style="display:block;" id="fig:map-prep"></span>
<img src="data:image/png;base64,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" alt="Map of potential sampling areas." width="100%" />
<p class="caption">
Figure 3: Map of potential sampling areas.
</p>
</div>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-electrofishing-sites">Table 5: </span>Potential Phase 1 assessment, Phase 2 assessment, and Electrofishing Locations
</caption>
<thead>
<tr>
<th style="text-align:right;">
id
</th>
<th style="text-align:left;">
stream_name
</th>
<th style="text-align:right;">
utm_zone
</th>
<th style="text-align:right;">
utm_easting
</th>
<th style="text-align:right;">
utm_northing
</th>
<th style="text-align:left;">
watershed_group_code
</th>
<th style="text-align:left;">
pscis_assessment_comment
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
125000
</td>
<td style="text-align:left;">
tributary to Parsnip River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed upstream continuosly for 350 m to beaver influenced wetland area where walking became difficult. Then stream was visited again upstream at 1.6 km upstream from crossing then again at approximately 2.5 km upstream of crossing. Undercut banks provide areas of deep cover ad Large woody debris is scattered througout. Overhanging vegetationalso provides cover througout. Pools observed were somewhat shallow but were preseetevery 20 - 30 m or so. Minnowtrapping conducted upstream and downstream of crossing. Electrofishing conducted downstream of the crossing. No fish captured upstream of the culvert. First beaver dam located approximately 330m upstream of the culvert.
</td>
</tr>
<tr>
<td style="text-align:right;">
125179
</td>
<td style="text-align:left;">
Unnamed tributary to Missinka River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration with habitat for rearing and overwintering upstream. Surveyed upstream for 520 m with no barriers to fish passage present. Bull trout and rainbow recorded upstream. Some deep pools for overwintering and rearing. Large woody debris and undercut banks throughout. Sections of gravel suitable for spawning. Good flow. Surveyed downstream for 360 m. No barriers observed and none likely downstream of surveyed section due to gradients. Abundant large woody debris and gravels suitable for spawning.
</td>
</tr>
<tr>
<td style="text-align:right;">
125180
</td>
<td style="text-align:left;">
tributary to Missinka River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569664
</td>
<td style="text-align:right;">
6053048
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed upstream of PSCIS crossing 125186 for a distance of 515 m. Good flow and abundant cover. Large woody debris and pools throughout. Frequet pockets of gravel suitable for spawning. Good candidate.
</td>
</tr>
<tr>
<td style="text-align:right;">
125231
</td>
<td style="text-align:left;">
tributary to Table River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065140
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed for 600m to new bridge (modelled crossing 16603641). Some deep pools and bounlders, udercut banks, gravels throughout. Abundant large wody debris throughout. Some debris steps from 30 - 70 cms high. No barriers. Rainbow trout known upstream (FIDQ 2020). Good candidate for rehabilitation.
</td>
</tr>
<tr>
<td style="text-align:right;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534600
</td>
<td style="text-align:right;">
6067770
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
Two additional culverts at 0.9m diameter.
</td>
</tr>
<tr>
<td style="text-align:right;">
198667
</td>
<td style="text-align:left;">
Tsatchuka Creek
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
500641
</td>
<td style="text-align:right;">
6089777
</td>
<td style="text-align:left;">
CARP
</td>
<td style="text-align:left;">
Grate on inlet and beaver influenced wetland upstream. Inlet blocked by beaver debris with beaver trap on inlet. Potentially good candidate for leveler to maintain beaver activity without attempting to remove the animals. Ministry of Transportation chris_culvert_id: 1997066. 13:04:57
</td>
</tr>
<tr>
<td style="text-align:right;">
198668
</td>
<td style="text-align:left;">
Tributary to McLeod Lake
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
<td style="text-align:left;">
Abundant gravels, suitable for spawning upstream. Although flows are minimal, the streams does still have water. Models as having over 3 km of habitat upstream below 5%. Although no fish are recorded as present upstream it seems highly likely that this would be a fish bearing stream. Outlet drop is 80cm. Steep section of pipe at the inlet recorded as inlet drop. Ministry of Transportation chris_culvert_id: 1996852. 13:40:04
</td>
</tr>
<tr>
<td style="text-align:right;">
198692
</td>
<td style="text-align:left;">
Tributary to Kerry Lake
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
511735
</td>
<td style="text-align:right;">
6059316
</td>
<td style="text-align:left;">
CRKD
</td>
<td style="text-align:left;">
Nice little stream with decent flow for this time of year. Pockets of gravel throughout and healthy shrub and mixed riparian. Fish presence unknown, but seems likely due to proximity to Kerry lake with low gradients. 17:14:13
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fish_passage_assessments" class="csl-entry">
BC Ministry of Environment. 2011. <em>Field Assessment for Determining Fish Passage Status of Closed Bottom Structures</em>. Manual. Victoria, British Columbia: BC Ministry of Environment. <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf</a>.
</div>
<div id="ref-confirmation_checklist_2011" class="csl-entry">
Fish Passage Technical Working Group. 2011. <span>“A <span>Checklist</span> for <span>Fish Habitat Confirmation Prior</span> to the <span>Rehabilitation</span> Fo a <span>Stream Crossing</span>.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf</a>.
</div>
<div id="ref-mcphail_carveth1993FieldKey" class="csl-entry">
McPhail, J. D., and R Carveth. 1993. <span>“Field <span>Key</span> to the <span>Freshwater Fishes</span> of <span>British Columbia</span>.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
